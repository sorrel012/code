
// JavaScript
    - 브라우저에서 동작하는 프로그래밍 언어
    - Netscape > Navigator
    - 가볍다 + 쉽다 = 기능 적음 > 어렵다.
    - C 계열 언어 > 기본 구문이 자바와 유사
    - Java <- (무관계) -> JavaScript
    - LiveScript -> JavaScript
    - 초반 > 폼태그 유효성 검사 + 링크 조작 + 이미지 조작 등 > BOM
      중반~2013() > 모든 태그 조작 > DOM
      후반(2014~) > ECMA2015(ES6) > Node.js 출시(구글 크롬 V8 엔진) 
                  > 비브라우저 환경에서 JavaScript 동작 > 서버 구축 or 그 이외 개발
                  

// JavaScript 역사
    1. Netxcape navigator > JavaScript1.0 > 1.1 > ... > 1.8
    2. Internet Explorer > JavaScript > JScript 1.0 > 2.0 > ... > 8.0
    3. ECMA > JavaScript > ECMAScript(ES) > ... > ECMAScript 2015(ES6) > ECMAScript 2020(ES11)
        - 현재 자바스크립트(ES6 기반)
    
        
// JavaScript가 하는 일

    1. 기본적인 프로그래밍 언어로서의 행동
        - 변수
        - 연산자
        - 제어문
        - 데이터 조작, 가공 등
        
    2. 브라우저에서만 할 수 있는 행동 > BOM, DOM
        - HTML/CSS 조작
        a. HTML Element 생성
        b. HTML Element 수정
        c. HTML Element 삭제
        d. HTML Attribute 생정/수정/삭제
        e. HTML PCDATA 생성/수정/삭제
        f. CSS 속성 색성/수정/삭제
        g. 폼태그 조작
        h. 이미지 조작
        i. 링크 조작
        j. 기타 객체 조작
    
    3. 서버 제작, 응용 프로그램 제작
        - Node.js
        
    4. 확장 라이브러리
        - jQuery
        
    5. JavaScript Framework
        - Angular
        - React
        - Vue.js


// 프로퍼티 
    1. HTML 속성을 그대로 똑같이 만들어 놓은 프로퍼티
    2. JavaScript가 독자적으로 만들어 놓은 프로퍼티


// HTML 문서에 JavaScript를 적용하는 방법

    1. 인라인 방식(X) > 이벤트 핸들러(Event Handler) == 이벤트
        - 태그에 직접 기재
        - 대부분의 태그에 onXXX 속성 제공
        
    2. 임베디드 방식
        - <script> 태그 내에 기재
        
    3. 외부 방식
        - *.js > 독립된 파일에 기재
        ~ <script src="URL">
        

// 구문의 실행 순서
    - 위 > 아래
    - 문장 단위
    - 연산자 우선순위
    
    - ★★★HTML과 JavaScript구문이 동시에 실행된다.
    
    
// 디버깅
    - 값 확인
    
    1. alert(값);
    2. console.log(new Date()); > 표준
    3. window.document.all > 사용 금지


// 자료형    
    
    1. number
        - 숫자형(정수, 실수)
    
    2. string
        - 문자, 문자열
    
    3. boolean
        - 논리형
        
    4. object 
        - 객체형
        - JavaScript에는 클래스가 없지만 객체는 있다.
        - 자바스크립트 > 객체 기반 프로그래밍 언어 (≠ 자바 > 객체 지향 프로그래밍 언어)
        
        a. 내장 객체
            - Date, Array, Math, Object. Option 등
            ~ new Date()
            ~ new Array()

        b. BOM 객체
            - window, document, form, text, button 등록
            - BOM 트리의 구성 요소들

        c. DOM 객체
            - element, attribute, text 등

        d. 사용자 정의 객체
            - JavaScript에는 클래스가 없다 > 원하는 형태(구조)의 객체를 만들 수 있다.
            - ES6에서 클래스 문법이 만들어졌다.
                > 진짜 클래스는 아니고 클래스를 흉내낸 문법 도입

            - 만드는 방법
                ① Object 클래스 사용
                ② {} : 객체 리터럴 표기법 사용               

        
    5. 기타(=상수)
        a. null
        b. undefined
        c. NaN(Not a Number) 


// 형변환
    - 함수 제공
        1. number parseInt(value)
        2. number parseFloat(value)            
        

// 변수, 상수(리터럴)
    - JavaScript는 변수의 타입이 없다.
    - 변수는 모든 자료형의 데이터를 저장할 수 있다.(= 자바 Object 변수)
    - 자바스크립트는 초기화가 되지 않은 변수의 상태를 null이라고 하지 않고, undefined라고 한다.
    - 전역 멤버(전역변수, 함수)는 자동으로 window 객체의 멤버(프로퍼티)가 된다.★★★
    
    - 변수 영역
        1. 전역 변수 > HTML 페이지 전역 > 선언문 실행(생성) ~ 페이지 종료(소멸)
        2. 지역 변수 > 블럭 영역 변수 X, 함수 영역 변수(O) > 함수만 지역으로 인식 > 제어문 인식 X

    - 변수 선언하기
        1. var  
            - BOM ~ DOM ~ DS6
            - function-scoped
            - 중복 선언 가능
            - 상수 선언 불가능

        2. let 
            - ES6
            - block-scoped
            - 중복 선언 불가능

        3. const
            - ES6
            - block-scoped
            - 중복 선언 불가능
    

// 연산자, 제어문, 문자 이스케이스
    - 자바와 동일    
    
    ※ == vs ===
        - ==  : 동등 비교 연산자. 자료형의 비교(X), 값만 비교(O) <-> !=
        - === : 동등 비교 연산자/ 자료형의 비교(O), 값만 비교(O) > 우리가 아는 동등 비교 연산자 <-> !==
    

// 함수      
    - 1급 객체, First class object
    - 함수를 객체처럼 취급한다. > 함수를 값처럼 취급할 수 있다.

    1. 함수를 변수에 담을 수 있다.(저장)
    2. 함수를 매개변수에 전달할 수 있다.
    3. 함수를 반환값으로 사용할 수 있다.

    - 함수를 만드는 방법
        1. 함수 선언문

            function m1(num)  {
                console.log('m3');           
            }

        2. 함수 표현식(리터럴)
            - 익명 함수(Anonymous Function)
            - 함수의 목적 : 함수를 변수에 넣기 위해서
                > 함수를 독립적으로 사용할 의도가 전혀 없다.
            - 이벤트에 함수를 사용하면 함수 오용 가능성이 없어 완전성, 가독성이 높아진다.

            const n3 = function m3() {
                console.log('m3');            
            }

        3.화살표 함수, Arrow Function
            - 자바의 람다 > 익명 객체의 추상 메소드를 표기하는 문법
            - 자바스크립트의 화살표 함수 > 익명 함수를 표기하는 문법
            - 화살표 함수 내의 this는 무조건 window를 참조한다.★★★
                > 화살표 함수를 이벤트에 사용할 때는 주의해야 한다.

            const n4 = () => {console.log('m3');};

                ~ 실행문 1줄이면 {} 생략 가능
                const f4 = () => console.log('f4');

                ~ 매개변수가 하나면 () 생략 가능
                const f6 = num => console.log(num);

                ~ 반환값이 유일하면 {}와 return문 생략 가능
                const f9 = () => 200;    

            - 스트림
                - 콜백 메소드, 콜백 함수 > Callback > 시스템(환경)에 의해서 호출되는 메소드
                
                a. forEach() : 매개변수를 받아 요소 소모
                b. map() : 앞의 요소를 가공해서 다른 요소로 반환
                c. filter() : 조건에 부합되는 요소만 반환
                ---------↓ES6↓----------
                d. find() : 요소 검색

// 생성자 함수
    - 멤버 초기화
    - 같은 구조(★)의 객체를 생성하는 것이 목표
    - 대문자로 시작한다.(일반 함수와 구분하기 위해)
    - new 연산자와 함께 호출해야 한다.


// Date
    - 내장 객체
    ~ var 변수명 = new Date();
    
    - 요소 출력
        ~ getYear: 두 자리 연도
        ~ getFullYear: 네 자리 연도
        ~ getMonth: 월-1        
        ~ getDate: 일
        ~ getDay: 요일(숫자, 일요일이 0부터 시작)
        ~ getHours: 시
        ~ getMinutes: 분
        ~ getSeconds: 초
        ~ getMilliseconds: 밀리초
        ~ getTime: 틱(ms)
        
    - 출력
        ~ toLocaleString: 날짜 + 시간
        ~ toLocaleDateString: 날짜만
        ~ toLocaleTimeString: 시간만
        
    - 특정시각 만들기
        ~ setFullYear(4자리 연도): 연도 설정
        ~ setMonth(월-1): 월 설정
        ~ setDate: 날짜 설정        
        
    - 연산
        1. 시각 - 시각
            ~ 시각변수 - 시각변수: 틱값 반환
            ~ (시각변수 - 시각변수)/1000/60/60/24: 일수로 표현
            
        2. 시각 + 시간 / 시각 - 시간
            ~ setTime(getTime() + (원하는 일수 * 24 * 60 * 60 * 1000))        
        
        
// 배열
    - Array(외형) + ArrayList(길이 가변, 자료형 자유)    
    ~ var 배열명 = new Array();
    
    - 초기화 
        1. var 배열명 = new Array(값);
        2. var 배열명 = [값] > 배열 리터럴 표현 > 더 많이 씀
    
    - 스택처럼 활용 가능
        ~ push, pop

    * 유사 배열: 배열은 아닌데, 배열처럼 보이게 만든 객체 
        - 스트림 계열 메소드 미지원
        - Array.from() : 유사배열을 진짜 배열로 바꾸는 함수

// HTML 속성 제어하기
    - CSS: 선택자 > 태그 검색 > 접근 > 서식 조작
    - JavaScript: 검색 도구 > 태그 검색 > 접근 > 태그 조작
        - HTML 계층 구조를 활용하여 탐색
            1. BOM        
            2. DOM
        
    1. HTML 태그 대부분의 속성은 JavaScript의 프로퍼티로 제공된다.
        - HTML : <input type="text" size="10">
        - JavaScript : txt1.size
        
    2. HTML 태그의 속성명을 그대로 JavaScript 프로퍼티명으로 사용한다.
    
    3. 대부분 읽기/쓰기 모두 지원한다. (일부 쓰기 or 읽기 전용이 있긴 하다.)
    
    4. 태그의 식별자나 근본적인 속상은 조작하지 않는다.
    
    5. 플래그 타입의 속성은 boolean으로 조작한다.
    
    6. HTML 속성명이 복합어면 캐멀표기법으로 작성한다.
    
    7. HTML 속성값이 열거형이거나 색상명이면 문자열로 작성한다.


// BOM, Browser Object Model > 비오엠
    - 초창기 모델
    - 현재까지 계속 사용
    - 선택적 모델 > 일부 태그만 관리 > 일부 태그만 조작 가능 > 빠진 태그는 조작 불가능
    - 이미지, 링크, 폼 태그 이외에는 조작이 불필요하다고 판단        
    - 태그의 name을 사용해서 접근한다.
    - id, class는 인식하지 못 한다.
    - HTML 태그의 속성만 조작 가능하다. > HTML RGB 16진수만 지원
    
    - 예약어
        ~ window: 창
            ~~ window.close(): 창을 닫아준다.
        ~ document: 문서 객체
 
// DOM, Document Object Model > 돔
    - BOM을 개선한 모델
    - 현재까지 계속 사용(주력)
    - BOM 기반 + 기능 추가 
    - DOM > BOM 확장 > DOM의 모든 기능을 BOM의 document 내부에 구현해놨다.
    - 모든 태그를 인식 > 모든 태그 조작 가능
    - name, id, class 모두 인식할 수 있다.(name 비권장)
    - 버전이 있다. (DOM Level 1 > DOM Level 2 > DOM Level 3)
        ~ DOM Level 0: BOM을 일컫기도 한다.

    - 태그 검색
        1. id 검색          > document.getElementById('id')
        2. class 검색       > document.getElementByClassName('id')
        3. name 검색        > document.getElementByName('id')
        4. 태그명 검색       > document.getElementByTagName('id')
        5. CSS 선택자 검색   > document.querySelector('selector')
                              document.querySelectorAll('selector')

    - DOM 트리 구성 요소(노드): 태그뿐만 아니라 다른 요소들도 포함
        1. 태그(1)
        2. 속성(2)
        3. PCDATA(3)
        4. 주석(8)
        5. 선언문(13)

    - DOM 트리 구성 노드의 프로퍼티 
        1. nodeType > 해당 노드가 어떤 형식인지 > 열거형(숫자)
        2. nodeName > 태그(태그명), 속성(속성명), PCDATA(#text)
        3. nodeValue > 태그(null), 속성(속성값), PCDATA(문자열)

    - 이벤트
        ~ addEventListener(원하는조작, 함수)    > 이벤트 설정
        ~ removeEventListener(원하는조작, 함수) > 이벤트 제거
        - 이벤트 매핑을 관리할 수 있다.
            > Invocation List(이벤트 함수 목록)


// BOM, DOM 
    1.태그 조작getElementsByTagName
        - 태그 검색(BOM, DOM)    
        - 속성 조작(BOM, DOM)    
        - PCDATA 조작(DOM) > 콘텐츠 조작 > 시작 태그와 끝 태그 사이의 내용물 조작
            a. innerText
                - 시작 태그와 끝 태그 사이의 문자열 읽기/쓰기 프로퍼티
                - 비표준(MS)

            b. innerHTML
                - 시작 태그와 끝 태그 사이의 문자열과 태그 읽기/쓰기 프로퍼티
                - 문자열 + 태그
                - 태그를 인식한다.

            c. outerText
                - 사용 안 함

            d. outerHTML
                - 사용 안 함

            e. textContent
                - 시작 태그와 끝 태그 사이의 문자열 읽기/쓰기 프로퍼티
                - 표준

    2. document
        - BOM: window가 document의 부모
        - DOM: document가 최상위 객체


// Axis(Traversing)
    - 본인을 기준으로 주변의 요소(부모, 자식, 형제)를 검색하는 도구
        
    - 자식 태그
        - childNodes: 자식 노드들
        - firstChild; 첫 번째 자식 노드 > me.childNodes[0];
        - lastChild> 마지막 자식 노드 > 

    - 바로 위의 형제
        ~ previousSibling
        ~ previousElementSibling

    - 바로 밑의 형제
        ~ nextSibling
        ~ nextElementSibling

    
// 이벤트, Event
    - 사건
    - 객체(혹은 태그)에서 발생하는 사건
    - 언제 발생할지 예측 불가능(시간)
    

// JavaScript Event Handling★★
    - 이벤트 등록(구현)
    - 사건 처리
    - 언제 발생할지 예측 불가능한 사건에 대해 처리를 하고 싶다. > 언젠가 사건이 발생하면 처리하기 위한 코드를 미리 준비한다. > 사건과 연결 > 이벤트 처리, 이벤트 매핑, 이벤트 구현 등
    
    1. 정적
        - HTML 코드에 직접 사용
    
    2. 동적
        - JavaScript 코드를 사용    

    - this: 이벤트 주체(이벤트가 걸린 태그)
        ※ 함수 내의 this는 window 객체(전역 객체)를 말한다.

// 이벤트 버블링(Event Bubbling), 이벤트 터널링(Event Tunneling, 이벤트 캡쳐링(Event Capturing))
    - 이벤트는 태그 계층구조에 따라 순차적으로 전달 및 실행된다.
        ~ 이벤트 터널링: 상위 계층부터 하위 계층까지 순차적으로 이벤트를 전달한다.
        ~ 이벤트 버블링: 하위 계층부터 상위 계층까지 순차적으로 이벤트를 수행한다.
    
    - 자바스크립트는 기본적으로 이벤트만 발생한다.(원하면 이벤트 터널링도 발생시킬 수는 있다. > DOM으로만 가능)
        > 내려가다가 이벤트가 걸린 곳에서 유턴한다.
            - event.target★★ , event.srcElement: 유턴하는 객체
            - this, event.currentTarget★★: 이벤트를 소유하는 객체

    - addEventListener(원하는조작, 함수, true): 이벤트 터널링 구현


// 마우스 관련 이벤트
    - onmouseXXX
    
    1. onmouseover(= onmouseenter)
        - 해당 객체의 영역에 마우스(커서)가 진입하는 순간 발생
    2. onmouseout(= onmouseleave)
        - 해당 객체의 영역에서 마우스(커서)가 빠져나가는 순간 발생
    3. onmousedown
        - 해당 객체의 영역에서 마우스 버튼을 누르는 순간 발생
    4. onmouseup
        - 해당 객체의 영역에서 마우스 버튼을 떼는 순간 발생
    5. onmousemove
        - 해당 객체의 영역에서 마우스가 움직일 때마다 발생

    ~ event.buttons: 마우스 버튼의 번호
        - 왼쪽(1), 오른쪽(2), 왼쪽+오른쪽(3), 휠버튼(4)
    
    ~ 마우스 커서 좌표    
        1. x, y
            - 문서 좌측 상단을 기준으로 한다.
            - 비표준(MS-IE) > 비권장
            
        2. clientX, clientY★★★★★
            - 문서 좌측 상단을 기준으로 한다.
            - 표준 > 권장
            ≒ CSS > position: absolute;
            
        3. screenX, screenY
            - 모니터 좌측 상단을 기준
            - 일상적으로는 다루기가 힘들다.
        
        4. offsetX, offsetY★★★★★
            - 이벤트 객체의 좌측 상단을 기준
            - 자기 자신이 기준이 된다.
            ≒ CSS > position: relative;

    ~ event.target, event.srcElement : 눌린 버튼의 프로퍼티 제공

    * onclick: 클릭했을 때 나타나는 이벤트
    * ondblclick: 더블클릭했을 때 나타나는 이벤트
    * onchange: 입력 컨트롤의 값이 변할 때 발생하는 이벤트
    * oninput: 입력 컨트롤의 값이 변하는 것을 실시간으로 보여주는 이벤트


// 키 관련 이벤트        
    - onkeyXXX
    - 포커스를 가지는 태그에서만 발생(텍스트 박스, 체크 박스 등)
        > 이미지 등의 태그에서 사용하려면 window에 걸어야 한다. > 전역 이벤트(화면의 모든 곳에서 발생)
    - 발생 순서: keydown > keypress > keyup
    - 키 입력 순서: keydown > 실제 문자 입력 > keyup
    - 평상시 키 이벤트 > keydown
      특별히 누른 키가 관여된 작업 > keyup
    
        1. onkeydown
            - 키를 눌렀을 때 발생
            - 문자에 반응하는 이벤트 X / 물리키에 반응하는 이벤트 O
            - 물리키에 반응하는 이벤트 > 어떤 키를 눌렀는지가 중요하다.
            - 키보드에 존재하는 모든 키에 반응한다.★★★★★★
            - 방금 입력한 문자는 필요 없을 때 사용!
        
        2. onkeyup
            - 키를 뗐을 때 발생
            - 방금 입력한 문자가 필요한 경우에 사용!
        
        3. onkeypress
            - 키를 눌렀을 때 발생
            - 문자에 반응하는 이벤트 O / 물리키에 반응하는 이벤트 X
            - 문자가 아닌 키에는 반응하지 않는다.★★★★★★
            - 잘 사용하지 않는다.

        ~ event.keyCode: 입력값 코드
            - 좌(37), 상(38), 우(39), 하(40)            
           
    
 // window 객체
    - BOM 트리 구조의 최상위 객체
    - 브라우저 창을 참조하는 객체
    - window 객체 조작 > 브라우저 창 조작
    - 열기☆, 닫기☆, 이동하기, 사이즈 조절 등
    
    ~ window.open(URL, Name, Options); //부모창 > 자식창 생성
        1. URL: 새 창의 URL
        2. Name: 새 창 이름 (이름을 비워두면 계속 새 창이 뜨고, 그렇지 않으면 새로고침 된다.)
        3. Options

    ~ window.close(); //자기 스스로 종료
    
    - 부모창에서 자식창을 조작하려면, 변수를 선언한 후 open할 때 변수에 담는다.
        ~ var child; > 변수 선언

          child = window.open('./ex17_child.html', 'child', 'width=300 height=200, left=0, top=0'); > 변수에 자식 window 객체 담기
    
          child.document.form1.txt1.value = '부모창에서 왔습니다.'; > 자식 window 객체 조작    

    - 자식창에서 부모창을 조작하려면, opener라는 예약어를 사용한다.
        ~ opener.document.form1.btn3.value = '부모창을 조작합니다.'


// screen 객체
    - window 객체의 자식
    - 화면 관련 정보 제공
    
    ~ availWidth
    ~ availHeight
    ~ colorDepth: 24bit
    ~ orientation


// location 객체
    - window의 자식
    - 현재 창의 페이지(URL)와 관련된 조작
    
    ~ href: 페이지 이동 변수 ★★★★★
    ~ replace: 페이지 이동 메소드
    ~ reload: 새로 고침


// history 객체
    - window의 자식
    - 브라우저의 탐색 기록(history) 영역에 접근하는 객체

    ~ back: 뒤로 가기
    ~ forward: 앞으로 가기
    ~ go(-2) : 2단계 뒤로 가기
    ~ go(2) : 2단계 앞으로 가기


// 내장 배열(컬렉션)
    - 문서 코드를 기반으로 자동 생성되는 배열을 제공한다.

    1. window.document.images: 문서 내의 모든 <img> 태그
    2. window.document.links: 문서 내의 모든 <a href=""> 태그
    3. window.document.anchors: 문서 내의 모든 <a name=""> 태그
    4. window.document.forms: 문서 내의 모든 <form> 태그
    5. window.document.forms[index].elements: 특정 <form> 태그 내의 모든 입력 태그
    6. window.document.forms[index].select.options: <option> 태그
        ~ var 변수명 = new Option(content, value); > option 연결
        ~ document.all.select의 name 이름.selectedIndex; > 선택된 항목의 인덱스 반환
        ~ document.all.select의 name 이름.options.add(변수명); > 동적으로 추가
        ~ document.all.select의 name 이름.options.remove(index); > 특정 index의 요소 삭제(shift 발생)
        ~ document.all.select의 name 이름.options.remove(selectedIndex); > 선택된 요소 삭제

    7. window.document.all: 문서상의 모든 태그: 비표준(MS)


// 메시지 박스, 대화 상자(Dialog Box)
    1. void alert(message): 메시지 전달용
    2. boolean confirm(message): : 메시지 전달용(선택)
    -----------------------------
    3. string prompt(message, value): 


// 타이머, toLocaleTimeString   
    
    - 타이머 생성
        1. setTimeout(함수, 시간)
            - 일회성 타이머

        2. setInterval(함수, 시간)
            - 반복성 타이머

    - 타이머 종료
        1. clearTimeout(id)
        2. clearInterval(id)


// 호이스팅, Hoisting
    - 코드를 실행하기 전, 변수 선언문과 함수 선언문은 해당 스코프의 최상단으로 끌어올려진다. > 코드 재배치
    - 함수 호이스팅★, 변수 호이스팅


// 클로저, Closure
    - 외부함수(포함하고 있는)의 변수에 접근할 수 있는 내부 함수
    - 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는 함수
    - 함수가 선언되는 시점에 생성되고, 함수가 실행되는 도중에 사용될 수 있다.

// Template string
    - 형식 문자열 제공
    
    1. 'string'
    2. "string"
    3. `string`: `(역따옴표, backtick, backquote)
        - 엔터도 입력이 가능하다.
