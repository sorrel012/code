1. 메모장
	- 코드 작성 > 소스 파일(*.java)
	- 산출물(결과) > "Hello.java"
	- 소스 파일 > 사람이 사용하는 언어로 구성 > 컴퓨터(CPU) > 이해 불가능(실행 불가능)
	
2. javac.exe Hello.java
	- 컴파일(Compile)
	- 프로그램 > 컴파일러(Compiler)
	- 사람 명령어 > (번역) > 기계어(Machine Code, 이진 데이터, Binary)
	- javac.exe > Java Compiler
	- 산출물(결과) > "Hello.class" > 실행 파일(클래스 파일) 
	- 자바의 컴파일 결과는 기계어가 아니다 > 중간 언어(IL) > 산출물
	
3.java.exe Hello
	- 자바 프로그램 실행
	- 2차 컴파일(Compile) > 인터프리터 > JIT(Just in time) 컴파일러
	- 실제 기계어로 변환 > 실행 가능한 상태로 변환
	- 산출물 x > 번역 후 결과를 따로 저장하지는 않는다.

//패키지 = 폴더
	- 자바 소스(*.java)를 관리하는 전용 폴더
	- 자바 소스는 항상 패키지로 관리한다.
	- 패키지명
		~ 마음대로 작성
		~ 영어 소문자 + 숫자(비권장)
		~ 단계 지정(Level)	


//메소드, Method
	- 메소드, 함수(Function), 프로시저(Procedure), 서브루틴(subRoutine)
	- (같은 목적을 가진) 코드의 집합 > 동일한 목적을 가지는 동일한 코드가 2번 이상 반복되면 안 되기 때문★
	- 메소드끼리의 선언 순서는 상관 없다. (main은 맨 위에 두는 편)
	
	1. 메소드 선언
		- 1회
		
	2. 메소드 호출
		- 무한대
		- 메소드 내의 코드 실현
		
	- 선언부 + 구현부
		~ 선언부(시그니처,sign): (접근지정자 + 정적키워드 +) 반환자료형 + 메소드명 + 인자리스트 
		~ 구현부(body): 메소드가 하려는 업무 코드 구현
		
		a. 메소드 인자리스트
			- 인자리스트, 인자(Arguments)
			- 파라미터(Parameters)
			- 매개변수
			- 메소드를 호출할 때 값을 전달해서, 메소드 내에서 사용할 수 있게 해주는 역할
			- 메소드 활용도를 높여준다. > 메소드 가용성 향상
			- 가인자 / 실인자
		
		b. 반환
			- 리턴문, 반환문
			- return 키워드 사용
			- return 뒤의 값 1개(★)를 돌려주는 역할.
			※빈 리턴문 : 메소드를 종료한다.
				~ void {return;}

//메소드 오버로딩, method overloading
	- 동일한 이름 메소드가 인자 리스트를 다양하게 가지면서 여러 개 선언하는 기술
	- 성능 향상x, 개발자에게 도움o > 메소드 이름을 외우기 편함.
	
	- 메소드 오버로딩 구현 조건 > 가능
		1. 매개변수의 개수
		2. 매개변수의 자료형
		
	- 메소드 오버로딩 구현 조건 > 불가능
		1. 매개변수의 이름
		2. 반환 값의 자료형
		
		~ public static void test() {}		
			~ public static void test() {}				//x
			~ public static void test(int n){}			//o
			~ public static void test(int m){}			//x
			~ public static void test(Stirng s){}		//o
			~ public static void test(int n, int m){}	//o


// 문서 주석, Document Comment
	- 생성한 메소드에 대한 설명을 달아준다.	
	- /** 치고 엔터!
	

// 클래스, Class
	- (같은 목적을 가진) 코드의 집합
	- 데이터 집합
	- 사용자 정의 자료형
	- 데이터 구조 명확 > 같은 성질의 데이터를 저장하는 식별자(변수)가 서로 다른 이름을 사용하는 문제 해결
	- 클래스의 객체(인스턴스)를 생성 : 
		~ Point  p1      	=     new     Point();
		  클래스 참조변수(객체)	= 객체생성연산자 생성자();
		  
	- 클래스 : 붕어빵틀,  설계도,	사람, 포메라니언  
	   객체 :   붕어빵,  제품,		홍길동,  똘이   
	
	- 객체를 생성한 후 해당 클래스의 멤버에 접근하기 위해 '.'(멤버 접근 연산자) 사용
		~ p1.y = 100;
	
	a. 멤버 변수
		- 객체를 생성할 때 멤버 변수도 같이 생성★
			~ Point p1	= new Point(); > 이 구문이 실행될 때 생성
		- 객체는 모든 참조가 끊기면  가비지가 된다. > 가비지 컬렉터가 객체 수거 > 객체를 소멸시킴 > 멤버 변수도 같이 소멸됨.★
	
	b. 멤버 메소드	
		- 자신만이 가진 데이터를 활용해서 행동해야 함(개성 있는 행동)
		- 웬만하면 멤버 변수를 활용해서 만드는 것이 좋다.			
		
	c. 내부 클래스, 중첩 클래스
	
	- 자바 클래스 파일(소스 파일)을 만드는 규칙
		1. 파일(*.java)의 이름과 public 클래스의 이름이 반드시 동일해야 한다.
		2. 1개의 파일 안에 여러 개의 클래스를 정의할 수 있다.
			> 단, 이 클래스들 중 public 키워드는 딱 1개의 클래스만 가질 수 있다.
		
		3. 1개의 파일 안에 1개 클래스만 선언한다.(권고) 
		
//객체, Object
	- 실존하고, 다른 객체와 구분되어지는 객체
	
//UML, Unified Modeling Language	
	- 여러 가지 다이어그램
		~ 클래스 다이어그램, 유스케이스 다이어그램, 시퀀스 다이어그램 ....
	
	
	
	
	
	